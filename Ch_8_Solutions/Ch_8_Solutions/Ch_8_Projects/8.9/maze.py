"""File: maze.pyProject 8.9Determine the solution to a maze problem.Uses a grid to represent the maze.  This grid is input froma text file.  Uses a generic backtracking algorithm, wherethe programmer can vary the type of collection used to holdthe choice points.  Uses a counter to track the number ofchoice points visited, and outputs this number.To run the application, press F5 for stacks, then entermain(LinkedQueue) at the next shell prompt for queues."""from grid import Gridfrom linkedstack import LinkedStackfrom linkedqueue import LinkedQueuefrom counter import Counterdef main(collectionType = LinkedStack):    """Default collection type is LinkedStack."""    maze = getMazeFromFile()    print(maze)    (startRow, startCol) = findStartPos(maze)    counter = Counter()    success = getOut(startRow, startCol, maze, collectionType, counter)    if success:        print("Maze solved:")        print(maze)    else:        print("No path out of this maze")    print("Number of choice points visited:", counter)    def getMazeFromFile():    """Reads the maze from a text file and returns a grid that    represents it."""    name = input("Enter a file name for the maze: ")    fileObj = open(name, 'r')    firstLine = list(map(int, fileObj.readline().strip().split()))    rows = firstLine[0]    columns = firstLine[1]    maze = Grid(rows, columns, "*")    for row in range(rows):        line = fileObj.readline().strip()        column = 0        for ch in line:            maze[row][column] = ch            column += 1    return mazedef findStartPos(maze):    """Returns the position of the start symbol in the grid."""    for row in range(maze.getHeight()):        for column in range(maze.getWidth()):            if maze[row][column] == 'P':                return (row, column)    return (-1, -1)                def getOut(row, column, maze, collectionType, counter):    """(row,column) is the position of the start symbol in the maze.    Returns True if the maze can be solved or False otherwise.    Uses a generic collection type to hold the choice points."""    # States are tuples of coordinates of cells in the grid.    collection = collectionType()    collection.add((row, column))    counter.increment()    while not collection.isEmpty():        (row, column) = collection.pop()        if  maze[row][column] == 'T':             return True        elif maze[row][column] != '.':            # Cell has not been visited, so mark it and add adjacent unvisited            # positions to the collection            maze[row][column] = '.'            # Try NORTH            if row != 0 and not maze[row - 1][column] in ('*', '.'):                collection.add((row - 1, column))                counter.increment()            # Try SOUTH            if row + 1 != maze.getHeight() and not maze[row + 1][column] in ('*', '.'):                         collection.add((row + 1, column))                             counter.increment()            # Try EAST            if column + 1 != maze.getWidth() and not maze[row][column + 1] in ('*', '.'):                         collection.add((row, column + 1))                             counter.increment()            # Try WEST            if column != 0 and not maze[row][column - 1] in ('*', '.'):                         collection.add((row, column - 1))                counter.increment()    return Falseif __name__ == "__main__": main()